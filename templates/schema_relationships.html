{% extends "base.html" %}

{% block title %}Schema Relationships - Schema Explorer{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <div>
            <h1><i class="fas fa-project-diagram"></i> Schema Relationships</h1>
            <p class="subtitle">Interactive visualization of database table relationships</p>
        </div>
    </div>

    <div class="card">
        <div class="card-header">
            <h2><i class="fas fa-sitemap"></i> Database Schema Map</h2>
            <div class="button-group">
                <button onclick="toggleFullscreen()" class="btn btn-secondary" id="fullscreenBtn">
                    <i class="fas fa-expand"></i> Full Screen
                </button>
                <button onclick="resetNetwork()" class="btn btn-secondary">
                    <i class="fas fa-undo"></i> Reset
                </button>
            </div>
        </div>
        
        <div class="card-body">
            <div id="loadingMessage" class="loading-indicator">
                <i class="fas fa-spinner fa-spin"></i> Loading schema relationships...
            </div>

            <div id="errorMessage" class="alert alert-error" style="display: none;"></div>

            <div id="legend" style="display: none; margin-bottom: 20px; padding: 20px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 8px;">
                <h3 style="margin: 0 0 15px 0; color: var(--accent-cyan);"><i class="fas fa-info-circle"></i> Legend</h3>
                
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                    <strong style="color: var(--text-primary); display: block; margin-bottom: 10px;">Table Colors:</strong>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: #ff6b6b; border: 2px solid #fff;"></span>
                            <span style="color: var(--text-dim);">Projects (top-level organization)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: #51cf66; border: 2px solid #fff;"></span>
                            <span style="color: var(--text-dim);">Drawings (CAD files & content)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: #ffd700; border: 2px solid #fff;"></span>
                            <span style="color: var(--text-dim);">Standards (company-wide rules)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: #ff9800; border: 2px solid #fff;"></span>
                            <span style="color: var(--text-dim);">Blocks & Layers (instances)</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: #00ffff; border: 2px solid #fff;"></span>
                            <span style="color: var(--text-dim);">Other tables</span>
                        </div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                    <div>
                        <strong style="color: var(--text-primary);">Nodes (Tables):</strong>
                        <ul style="margin: 10px 0 0 20px; color: var(--text-dim);">
                            <li>Size indicates number of rows</li>
                            <li>Click to view table details</li>
                            <li>Drag to reposition</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: var(--text-primary);">Edges (Relationships):</strong>
                        <ul style="margin: 10px 0 0 20px; color: var(--text-dim);">
                            <li>Arrows show foreign key direction</li>
                            <li>Hover to see column names</li>
                            <li>Connected tables share data</li>
                        </ul>
                    </div>
                    <div>
                        <strong style="color: var(--text-primary);">Interaction:</strong>
                        <ul style="margin: 10px 0 0 20px; color: var(--text-dim);">
                            <li>Scroll to zoom in/out</li>
                            <li>Drag background to pan</li>
                            <li>Double-click node for details</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div id="networkContainer" style="display: none; width: 100%; height: 600px; border: 1px solid rgba(0,255,255,0.3); border-radius: 8px; background: rgba(0,0,0,0.3);">
                <!-- Floating popup for fullscreen mode -->
                <div id="nodePopup" class="node-popup">
                    <div class="node-popup-title" id="popupTitle"></div>
                    <div class="node-popup-description" id="popupDescription"></div>
                </div>
            </div>

            <div id="tableDetails" style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.2); border-radius: 8px;">
                <h3 style="margin: 0 0 15px 0; color: var(--accent-cyan);"><i class="fas fa-table"></i> <span id="detailTableName"></span></h3>
                <div id="detailContent"></div>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vis-network@latest/standalone/umd/vis-network.min.js"></script>

<style>
.loading-indicator {
    text-align: center;
    padding: 40px;
    color: var(--accent-cyan);
    font-size: 18px;
}

.alert {
    padding: 15px 20px;
    border-radius: 8px;
    margin-bottom: 20px;
}

.alert-error {
    background: rgba(220, 53, 69, 0.1);
    border: 1px solid rgba(220, 53, 69, 0.3);
    color: #ff6b6b;
}

#networkContainer {
    position: relative;
}

#networkContainer.fullscreen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
    background: #000000 !important;
    border: none !important;
    border-radius: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
}

#networkContainer.fullscreen #tableDetails {
    display: none !important;
}

.node-popup {
    position: fixed;
    display: none;
    max-width: 400px;
    padding: 20px 25px;
    background: rgba(0, 20, 40, 0.95);
    border: 2px solid rgba(0, 255, 255, 0.6);
    border-radius: 8px;
    color: #ffffff;
    z-index: 10001;
    box-shadow: 0 8px 32px rgba(0, 255, 255, 0.3);
    pointer-events: none;
    animation: popupFadeIn 0.3s ease-out;
}

.node-popup.visible {
    display: block;
}

.node-popup-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: bold;
    color: #00ffff;
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.3);
}

.node-popup-description {
    font-size: 14px;
    line-height: 1.6;
    color: rgba(255, 255, 255, 0.9);
}

@keyframes popupFadeIn {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.vis-network {
    outline: none;
}

.column-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 10px;
    margin-top: 15px;
}

.column-item {
    padding: 8px 12px;
    background: rgba(255,255,255,0.05);
    border-left: 3px solid rgba(0,255,255,0.5);
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
}

.column-item.primary-key {
    border-left-color: #ffd700;
}

.column-name {
    font-weight: bold;
    color: var(--accent-cyan);
}

.column-type {
    color: var(--text-dim);
    font-size: 12px;
}

.stats-row {
    display: flex;
    gap: 30px;
    margin: 15px 0;
    padding: 15px;
    background: rgba(0,0,0,0.2);
    border-radius: 6px;
}

.stat-item {
    display: flex;
    flex-direction: column;
}

.stat-label {
    font-size: 12px;
    color: var(--text-dim);
    text-transform: uppercase;
}

.stat-value {
    font-size: 24px;
    font-weight: bold;
    color: var(--accent-cyan);
}

.table-description {
    margin: 20px 0;
    padding: 20px;
    background: linear-gradient(135deg, rgba(0,255,255,0.1) 0%, rgba(0,100,255,0.05) 100%);
    border-left: 4px solid var(--accent-cyan);
    border-radius: 8px;
}

.table-description p {
    color: var(--text-primary);
    line-height: 1.8;
    font-size: 15px;
    margin: 0;
    text-align: justify;
}
</style>

<script>
let network = null;
let schemaData = null;
let physicsEnabled = true;

// Natural language descriptions for each table
const tableDescriptions = {
    // Project Organization Tables
    'projects': 'This table acts as the top-level container for organizing all your CAD work by client or project. Think of it like a filing cabinet drawer - each project holds all the related drawings for a specific building, development, or client engagement. It stores basic information like the project name and client name, and when you delete a project, all its associated drawings are automatically removed too. This helps keep everything organized so you can quickly find all drawings related to a particular job.',
    
    'drawings': 'Each row in this table represents one CAD file (like a floor plan, site plan, or detail sheet). Drawings belong to a parent project and contain critical information about the CAD file itself - what units it uses (feet, meters), what scale it\'s drawn at, and how it aligns with real-world GPS coordinates. This table is the bridge between your organizational structure (projects) and the actual geometric content (lines, text, dimensions). Every entity, text note, and dimension in your CAD file links back to a drawing in this table.',
    
    // CAD Standards Reference Tables
    'layer_standards': 'This is your organization\'s "official rulebook" for CAD layers - it defines what layers should exist, what colors they should be, and what linetypes they use. For example, it might specify that all wall layers must be red with a continuous linetype. These standards ensure consistency across all your drawings and help different team members produce drawings that look the same. When someone creates a new layer in a drawing, the system can check this table to make sure they\'re following company standards and using the approved layer names, colors, and properties.',
    
    'block_standards': 'Think of this as your library of reusable symbols and components - things like door symbols, north arrows, title blocks, or electrical fixtures. Each standard block has a name, category (like "Architectural" or "Electrical"), and a description of what it represents. Some entries even include SVG preview images so you can see what the symbol looks like before placing it. This table defines what symbols SHOULD exist, while the block_inserts table tracks where they\'re actually used in your drawings.',
    
    'dimension_styles': 'This table stores templates that control how dimensions look when you measure things in CAD drawings. Each style defines settings like how tall the dimension text should be, how big the arrows are, what colors to use, and how far extension lines extend from the object being measured. Having standard dimension styles ensures that all dimensions in your company\'s drawings look consistent and professional, whether they\'re showing the length of a wall or the radius of a curve.',
    
    'hatch_patterns': 'Hatch patterns are the repetitive fills used to represent different materials in CAD drawings - like the crosshatching for concrete, diagonal lines for earth/soil, or dots for gravel. This table stores your organization\'s approved hatch patterns with their names, what type they are (predefined AutoCAD patterns or custom ones), and what material they represent. When someone needs to show a concrete wall in a drawing, they can pick the correct hatch pattern from this standards table to ensure it matches all other concrete representations in your drawings.',
    
    // Drawing-Specific Instance Tables
    'layers': 'While layer_standards defines what layers SHOULD exist company-wide, this table tracks the actual layers that exist in each specific drawing file. Every drawing might have its own set of layers (like WALLS, DOORS, WINDOWS), and each layer has properties like color, linetype, lineweight, and whether it\'s frozen or locked. A layer in this table can optionally reference a layer standard to indicate it\'s following company guidelines. This two-table system (standards vs. instances) lets you have both company-wide rules and drawing-specific flexibility.',
    
    'block_inserts': 'Every time you place a symbol/block in a CAD drawing (like dropping a door symbol into a floor plan), that placement gets recorded here. This table stores where the block was inserted (X, Y, Z coordinates), how it was scaled (maybe 2x larger or 0.5x smaller), and what angle it was rotated to. It also captures any custom text that was filled in (like a door number or room name) in a flexible JSONB field. This allows the system to precisely recreate every symbol placement when exporting back to DXF format.',
    
    // Drawing Entity Tables
    'drawing_entities': 'This is where the actual geometry lives - all the lines, circles, arcs, and polylines that make up your CAD drawings are stored here as PostGIS spatial objects. Each entity knows what layer it\'s on, whether it\'s in model space or paper space, its color, linetype, and lineweight. The geometry is stored in a format that lets you do spatial queries (like "find all circles within this area") and export it back to DXF exactly as it was imported. Think of this as the digital representation of everything you\'d draw with a pencil on paper.',
    
    'drawing_text': 'Every piece of text in your CAD drawings - room labels, dimensions, notes, callouts - is stored in this table. It captures not just the text content itself, but exactly where it\'s positioned (X, Y, Z), how tall it is, what angle it\'s rotated, and how it\'s aligned (left, center, right, top, middle, bottom). This ensures that when you export a drawing back to DXF, all your text notes and labels appear in exactly the right spots with the right formatting. Text is separate from entities because it has unique properties like font styles and justification.',
    
    'drawing_dimensions': 'Dimensions are the measurements shown in CAD drawings (like "10\' 0\\"" showing a wall length). This table stores each dimension with its measurement geometry (the lines and arrows), what type it is (linear, angular, radial, etc.), and what dimension style controls its appearance. Dimensions can have override values (when you want to show something other than the actual measurement), and they reference dimension_styles to maintain consistent formatting. This table is separate from regular entities because dimensions have complex properties and behaviors that regular lines don\'t have.',
    
    'drawing_hatches': 'When you fill an area with a pattern (like showing a concrete wall with diagonal lines or a lawn area with grass symbols), that\'s a hatch. This table stores the boundary of each hatched area as a polygon, what pattern fills it, and properties like the pattern scale and rotation angle. The boundary geometry is stored as PostGIS polygons so you can calculate areas and do spatial analysis. Each hatch references a pattern from the hatch_patterns table to ensure material representations stay consistent across your drawings.',
    
    'layout_viewports': 'In CAD, you create drawings in "model space" (full scale) but print them from "paper space" (scaled down onto sheet layouts). Viewports are windows on your paper sheets that show specific views of the model at specific scales. This table tracks each viewport\'s location on the sheet, what part of the model it shows, what scale it\'s displayed at (like 1/4"=1\'-0"), and which layers are frozen (hidden) in that particular view. This allows one model to be shown multiple times on a sheet at different scales and with different layer visibility.',
    
    // Usage Tracking Tables
    'drawing_layer_usage': 'This is an analytics table that tracks which layers are actually being used in each drawing and how heavily. It counts how many entities exist on each layer in each drawing, making it easy to answer questions like "Which layers have the most content?" or "Is this layer even being used?" This information helps with layer management, cleanup operations, and understanding how your team structures their drawings. It\'s updated during the import process to give you instant insights into layer usage patterns.',
    
    'drawing_linetype_usage': 'Similar to layer usage tracking, this table counts how many times each linetype (solid, dashed, dotted, etc.) is used in each drawing. This helps you understand which linetypes are popular, which are unused, and ensures you export all necessary linetype definitions when creating a DXF file. If a drawing uses 5 different linetypes, you need to make sure all 5 are properly defined in the exported DXF, and this table helps track that automatically.',
    
    // Export Job Tracking
    'export_jobs': 'Every time you export a drawing from the database back to a DXF file, the system creates a job record here to track the operation. It records what format was requested (DXF or DWG), what version (AutoCAD 2013, 2018, etc.), where the output file was saved, and detailed statistics about what was exported (how many entities, text objects, dimensions, hatches). If the export fails, it captures the error message. This provides a complete audit trail of all exports and helps troubleshoot issues when exports don\'t work as expected.',
    
    // Additional Standards Tables (if they exist)
    'abbreviations': 'CAD drawings are full of abbreviations to save space (like "CLG" for ceiling, "FND" for foundation, or "EXT" for exterior). This table stores your organization\'s approved abbreviations with their full meanings, ensuring everyone uses the same shorthand consistently. When reviewing drawings or training new team members, this acts as a reference dictionary. Some CAD standards portals even display this table to help employees look up unfamiliar abbreviations quickly.',
    
    'details': 'Standard construction details are pre-drawn solutions for common building conditions (like how a wall meets a foundation, or how to flash a window). This table catalogs your organization\'s library of standard details with their names, numbers, descriptions, and sometimes links to the actual detail drawings. Instead of redrawing common details for every project, team members can reference standard details from this library, ensuring consistency and saving drafting time.',
    
    'colors': 'This table defines your organization\'s standard CAD color palette with each color\'s numeric ACI (AutoCAD Color Index) value, RGB values for display, and HEX codes for web use. Having a standardized color palette ensures that colors mean the same thing across all drawings - for example, red might always mean demolition, yellow might always mean new construction. This table helps maintain visual consistency and can support automated checking to ensure drawings use approved colors only.',
    
    'linetypes': 'Linetypes define line patterns like solid (continuous), dashed, dotted, dash-dot, or custom patterns. This table stores your organization\'s approved linetypes with their names and pattern definitions. Different linetypes convey different meanings in technical drawings (like hidden lines being dashed, centerlines being dash-dot). By standardizing linetypes, you ensure that a dashed line means the same thing in every drawing your organization produces.',
    
    'text_styles': 'Text styles are templates that control font selection, text height, width factor, and other properties for text in CAD drawings. This table stores your organization\'s approved text styles (like "Title Text", "Note Text", "Dimension Text") with their formatting rules. Using standardized text styles ensures that all drawings have consistent typography and professional appearance, and makes it easy to update text formatting across many drawings by changing the style definition.',
    
    'materials': 'This table catalogs construction materials with their properties, specifications, and how they should be represented in drawings. It might include information about concrete mixes, steel grades, wood species, or insulation types. Having a materials database helps ensure that specifications in drawings match actual products available for construction, and can link materials to their corresponding hatch patterns or layer assignments for visual consistency.',
    
    'sheet_templates': 'Sheet templates define standard sheet sizes, title block layouts, and formatting for different types of drawings (like architectural floor plans vs. electrical diagrams vs. structural details). This table stores template names, sheet sizes (like 24"x36" or A1), and configuration information. Using standard sheet templates ensures that all your organization\'s drawings have consistent borders, title blocks, and professional appearance regardless of who creates them.',
    
    'plotstyles': 'Plot styles (also called CTB/STB files in AutoCAD) control how drawings appear when printed - they map screen colors to print colors, set line weights for plotting, and control other print-specific settings. This table stores your organization\'s approved plot styles to ensure drawings print consistently. For example, it might specify that all yellow lines on screen print as thin black lines on paper, or that red lines print thicker than blue lines.',
    
    'viewports_standards': 'While layout_viewports tracks actual viewport instances in drawings, this table might define standard viewport configurations that should be used (like "1/8 inch scale plan view" or "detail callout at 3 inch scale"). Having standard viewport configurations helps team members set up sheet layouts correctly and ensures that common drawing scales are used consistently across projects.',
    
    'annotations': 'This table stores standard annotation styles and configurations for leader lines, multileaders, and other annotation objects that point to features and add notes. Annotation standards might control arrow styles, text formatting, leader line properties, and other details. Consistent annotation styles make drawings easier to read and understand, and help maintain professional appearance across all your organization\'s construction documents.',
    
    'symbol_categories': 'If your organization has hundreds or thousands of standard symbols (blocks), this table organizes them into hierarchical categories for easier browsing and selection. Categories might include "Architectural > Doors", "Electrical > Lighting", "Plumbing > Fixtures", etc. This organizational structure helps users find the right symbol quickly rather than scrolling through a huge unsorted list, and supports building user-friendly symbol palette interfaces.',
    
    'code_references': 'Construction drawings must comply with building codes, accessibility standards, and regulatory requirements. This table catalogs relevant code sections, standards documents (like IBC, ADA, NFPA), and regulatory references that apply to your projects. Linking code references to drawing elements helps ensure compliance and provides documentation for plan reviewers and inspectors. It serves as a quick-reference library of the rules that govern your designs.',
    
    'standard_notes': 'Instead of retyping the same construction notes on every drawing ("All dimensions to be verified in field" or "Contractor to coordinate all locations"), this table stores a library of pre-approved notes that can be inserted into drawings. Each note has an ID, category, and the full text. Using standard notes ensures consistent language across drawings, reduces typos, matches your organization\'s legal review, and saves time by eliminating repetitive typing.',
    
    'drawing_scales': 'Different types of drawings are typically shown at different scales (floor plans at 1/4"=1\'-0", details at 1"=1\'-0", site plans at 1"=20\'). This table defines what scales should be used for different drawing types in your organization. Having standard scales ensures consistency, makes drawings easier to read (people expect certain scales for certain drawing types), and helps team members set up new drawings correctly without having to guess what scale to use.',
    
    // Sheet Set Manager Tables
    'project_details': 'This table extends the basic projects table with comprehensive project metadata needed for construction document deliverables. It stores detailed information like full project addresses, engineer of record, jurisdiction, permit numbers, and other critical data that appears in title blocks and cover sheets. This information is essential for regulatory compliance, permitting, and coordinating with building departments and plan reviewers.',
    
    'sheet_category_standards': 'Construction document sheets are organized into standard categories (like COVER sheets, DEMOLITION plans, GRADING plans, UTILITY plans) that follow industry conventions. This table defines these standard categories with their codes, full names, hierarchy ordering, and what types of content belong in each category. Having standardized categories ensures that your sheet sets follow professional conventions and makes it easy for contractors, reviewers, and other stakeholders to find information quickly.',
    
    'sheet_sets': 'A sheet set is a collection of sheets that get delivered together as a package - like "100% Civil Plans for Permitting" or "Addendum #2 Construction Documents". This table organizes sheets into deliverable packages, tracking what phase they belong to (Schematic Design, Design Development, Construction Documents), what discipline (Civil, Architectural, MEP), their status (Draft, In Review, Issued), and when they were issued. This allows you to manage multiple versions of drawing sets and track what sheets were included in each submittal.',
    
    'sheets': 'Each row represents one individual sheet in a construction document set - like sheet C-1.1 "Site Plan" or sheet S-3.5 "Foundation Details". This table stores the sheet code (following numbering conventions), title, category, hierarchical ordering, scale, size (24x36, 11x17, etc.), and revision information. Sheets can be organized into sheet sets for delivery, and the system tracks which DXF drawing files and layout tabs correspond to each sheet through the sheet_drawing_assignments table.',
    
    'sheet_drawing_assignments': 'This junction table connects individual sheets to their corresponding CAD drawing files and layout tabs. A single sheet (like "Site Plan C-1.1") might be laid out in a specific layout tab within a DXF file, and this table records that relationship. This linkage enables the system to automatically export the correct layout from the correct drawing file when generating final sheet PDFs or DWG files. It also tracks which sheets have been assigned to drawings versus which sheets still need to be drafted.',
    
    'sheet_revisions': 'Construction documents go through multiple revisions during design and construction (Revision 0, Rev A, Rev B, etc.), and this table tracks the complete revision history for each sheet. Each revision records what changed, when it was issued, who issued it, why the revision was necessary, and any reference numbers (like RFI numbers or change order numbers). This provides a complete audit trail of document changes, which is critical for construction administration and avoiding disputes about what information was shown when.',
    
    'sheet_relationships': 'Sheets often reference other sheets - a detail sheet might say "See Sheet C-2.3 for plan view", or a plan might continue onto another sheet with "Continued on Sheet C-1.2". This table captures these cross-references and relationships between sheets, including reference types (references, detail_of, continued_from, etc.). Tracking these relationships helps ensure that when you revise one sheet, you remember to update any related sheets, and helps users navigate through multi-sheet drawing sets.',
    
    // Sheet Note Manager Tables
    'standard_notes': 'Construction drawings require extensive notes explaining construction requirements, material specifications, code compliance, and coordination instructions. Rather than retyping common notes on every project, this table stores a master library of company-approved standard notes with their IDs, categories (General, Grading, Utilities, etc.), titles, and full text. Using standard notes ensures consistent language across projects, reduces typos, matches legal review, saves drafting time, and makes it easy to update note text across all future projects when codes or standards change.',
    
    'sheet_note_sets': 'Each project typically needs its own collection of notes (a "note set") that might include a mix of standard company notes plus project-specific custom notes. This table organizes notes into project-specific sets with version tracking and activation status. For example, a project might have multiple note sets like "Draft Note Set v1", "100% Submittal Notes", and "Final Construction Notes". Only the activated note set for a project will be used to generate note legends on drawing sheets. This versioning system lets you prepare updated notes without affecting currently issued drawings.',
    
    'project_sheet_notes': 'This table stores the actual notes that belong to each project note set - it acts as the "working collection" of notes for a specific project. Each entry either references a standard_note from the company library (via standard_note_id foreign key) or contains custom note text written specifically for this project (when standard_note_id is NULL). The table also tracks usage counts showing how many sheets each note is assigned to, helping you understand which notes are most commonly used and which might be obsolete. Display codes, titles, and text can be customized per project while still maintaining the link back to standard notes.',
    
    'sheet_note_assignments': 'Once you have a collection of project notes, this table assigns specific notes to specific drawing sheets and layout tabs. Each assignment records which note appears on which sheet, in what sequence/order it should appear in the note legend, and whether it should be displayed in the legend (some notes might be "hidden" or for reference only). This fine-grained control allows different sheets in the same set to show different subsets of notes - for example, grading sheets show grading notes, utility sheets show utility notes - even though they all draw from the same project note set.',
    
    'sheet_note_legend': 'While not a table itself, the sheet note legend API endpoint generates formatted, ready-to-insert note legends for CAD drawings. It queries the note assignments for a specific sheet and layout, retrieves the note text, sequences them properly, formats them with display codes (like "1.", "2.", "3."), and returns a complete legend block that can be inserted into title blocks or note areas on construction drawings. This automation ensures that note legends are always current, properly formatted, and match the assigned notes - eliminating manual copying and reducing errors.'
};


async function loadSchemaData() {
    try {
        const response = await fetch('/api/schema/relationships');
        
        if (!response.ok) throw new Error('Failed to load schema data');
        
        schemaData = await response.json();
        
        if (schemaData.error) {
            throw new Error(schemaData.error);
        }
        
        // Show container BEFORE rendering (Vis.js needs visible container for dimensions)
        const loading = document.getElementById('loadingMessage');
        const container = document.getElementById('networkContainer');
        const legend = document.getElementById('legend');
        
        loading.style.display = 'none';
        container.style.display = 'block';
        legend.style.display = 'block';
        
        // Force browser reflow to ensure visual update
        void container.offsetHeight;
        
        console.log('Rendering network with', schemaData.tables.length, 'tables and', schemaData.relationships.length, 'relationships');
        renderNetwork();
    } catch (error) {
        console.error('Error in loadSchemaData:', error);
        showError('Error loading schema: ' + error.message);
    }
}

function showError(message) {
    document.getElementById('loadingMessage').style.display = 'none';
    const errorDiv = document.getElementById('errorMessage');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

function renderNetwork() {
    const container = document.getElementById('networkContainer');
    
    if (!container) {
        console.error('Container not found!');
        return;
    }
    
    // Check if vis is loaded
    if (typeof vis === 'undefined') {
        console.error('Vis.js library not loaded!');
        showError('Visualization library failed to load. Please refresh the page.');
        return;
    }
    
    // Create nodes from tables
    const nodes = schemaData.tables.map(table => {
        const rowCount = table.row_count || 0;
        const size = Math.max(20, Math.min(50, 20 + Math.log10(rowCount + 1) * 10));
        
        // Categorize tables by type
        let color = '#00ffff';
        if (table.table_name.includes('project')) {
            color = '#ff6b6b';
        } else if (table.table_name.includes('drawing')) {
            color = '#51cf66';
        } else if (table.table_name.includes('standards') || table.table_name.includes('_standard')) {
            color = '#ffd700';
        } else if (table.table_name.includes('block') || table.table_name.includes('layer')) {
            color = '#ff9800';
        }
        
        return {
            id: table.table_name,
            label: table.table_name,
            title: `${table.table_name}\n${rowCount} rows\n${table.column_count} columns`,
            size: size,
            color: {
                background: color,
                border: color,
                highlight: {
                    background: color,
                    border: '#ffffff'
                }
            },
            font: {
                color: '#ffffff',
                size: 14,
                face: 'Rajdhani'
            },
            data: table
        };
    });
    
    // Create edges from relationships
    const edges = schemaData.relationships.map((rel, index) => {
        return {
            id: index,
            from: rel.source_table,
            to: rel.target_table,
            arrows: 'to',
            title: `${rel.source_table}.${rel.source_column} → ${rel.target_table}.${rel.target_column}`,
            color: {
                color: 'rgba(0, 255, 255, 0.4)',
                highlight: 'rgba(0, 255, 255, 0.8)',
                hover: 'rgba(0, 255, 255, 0.6)'
            },
            width: 2,
            smooth: {
                type: 'curvedCW',
                roundness: 0.2
            },
            data: rel
        };
    });
    
    const data = { nodes: nodes, edges: edges };
    
    const options = {
        physics: {
            enabled: true,
            solver: 'forceAtlas2Based',
            forceAtlas2Based: {
                gravitationalConstant: -50,
                centralGravity: 0.01,
                springLength: 200,
                springConstant: 0.08,
                damping: 0.4,
                avoidOverlap: 0.5
            },
            stabilization: {
                iterations: 100
            }
        },
        interaction: {
            hover: true,
            tooltipDelay: 100,
            zoomView: true,
            dragView: true
        },
        nodes: {
            shape: 'dot',
            borderWidth: 2,
            shadow: true
        },
        edges: {
            shadow: true
        }
    };
    
    network = new vis.Network(container, data, options);
    
    // Fit network after stabilization (critical for proper rendering)
    network.once('stabilizationIterationsDone', function() {
        network.fit();
        console.log('Network stabilized and fitted to view');
    });
    
    // Event listeners
    network.on('click', function(params) {
        if (params.nodes.length > 0) {
            const tableName = params.nodes[0];
            const isFullscreen = document.getElementById('networkContainer').classList.contains('fullscreen');
            
            if (isFullscreen) {
                showNodePopup(tableName, params.pointer.DOM);
            } else {
                showTableDetails(tableName);
            }
        } else if (document.getElementById('networkContainer').classList.contains('fullscreen')) {
            // Hide popup when clicking empty space in fullscreen
            hideNodePopup();
        }
    });
    
    network.on('doubleClick', function(params) {
        if (params.nodes.length > 0) {
            const tableName = params.nodes[0];
            network.focus(tableName, {
                scale: 1.5,
                animation: true
            });
        }
    });
}

function showTableDetails(tableName) {
    const table = schemaData.tables.find(t => t.table_name === tableName);
    const columns = schemaData.columns[tableName] || [];
    const relationships = schemaData.relationships.filter(r => 
        r.source_table === tableName || r.target_table === tableName
    );
    
    document.getElementById('detailTableName').textContent = tableName;
    
    let html = `
        <div class="stats-row">
            <div class="stat-item">
                <span class="stat-label">Total Rows</span>
                <span class="stat-value">${table.row_count || 0}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Columns</span>
                <span class="stat-value">${columns.length}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Relationships</span>
                <span class="stat-value">${relationships.length}</span>
            </div>
        </div>
    `;
    
    // Add natural language description if available
    const description = tableDescriptions[tableName];
    if (description) {
        html += `
            <div class="table-description">
                <h4 style="color: var(--accent-cyan); margin: 0 0 10px 0;">
                    <i class="fas fa-info-circle"></i> What This Table Does
                </h4>
                <p>${description}</p>
            </div>
        `;
    }
    
    html += `
        <h4 style="color: var(--text-primary); margin: 20px 0 10px 0;">
            <i class="fas fa-columns"></i> Columns
        </h4>
        <div class="column-list">
    `;
    
    columns.forEach(col => {
        const pkClass = col.is_primary_key ? 'primary-key' : '';
        const pkIcon = col.is_primary_key ? '<i class="fas fa-key" style="color: #ffd700;"></i> ' : '';
        html += `
            <div class="column-item ${pkClass}">
                <div class="column-name">${pkIcon}${col.column_name}</div>
                <div class="column-type">${col.data_type} ${col.is_nullable === 'NO' ? '(NOT NULL)' : ''}</div>
            </div>
        `;
    });
    
    html += `</div>`;
    
    if (relationships.length > 0) {
        html += `
            <h4 style="color: var(--text-primary); margin: 20px 0 10px 0;">
                <i class="fas fa-link"></i> Relationships
            </h4>
            <ul style="margin: 0; padding-left: 20px; color: var(--text-primary);">
        `;
        
        relationships.forEach(rel => {
            if (rel.source_table === tableName) {
                html += `<li><strong>${rel.source_column}</strong> → ${rel.target_table}.${rel.target_column}</li>`;
            } else {
                html += `<li>${rel.source_table}.${rel.source_column} → <strong>${rel.target_column}</strong></li>`;
            }
        });
        
        html += `</ul>`;
    }
    
    document.getElementById('detailContent').innerHTML = html;
    document.getElementById('tableDetails').style.display = 'block';
    
    // Scroll to details
    document.getElementById('tableDetails').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function showNodePopup(tableName, position) {
    const popup = document.getElementById('nodePopup');
    const title = document.getElementById('popupTitle');
    const description = document.getElementById('popupDescription');
    
    // Get description if available
    const desc = tableDescriptions[tableName];
    
    // Set content
    title.textContent = tableName;
    description.textContent = desc || 'No description available for this table.';
    
    // Position the popup near the click, with smart positioning to avoid edges
    const popupWidth = 400; // max-width from CSS
    const popupHeight = 300; // estimated max height
    const margin = 30; // margin from edges
    
    let left = position.x + 20;
    let top = position.y + 20;
    
    // Adjust if too close to right edge
    if (left + popupWidth > window.innerWidth - margin) {
        left = position.x - popupWidth - 20;
    }
    
    // Adjust if too close to bottom edge
    if (top + popupHeight > window.innerHeight - margin) {
        top = window.innerHeight - popupHeight - margin;
    }
    
    // Adjust if too close to top edge
    if (top < margin) {
        top = margin;
    }
    
    // Adjust if too close to left edge
    if (left < margin) {
        left = margin;
    }
    
    popup.style.left = left + 'px';
    popup.style.top = top + 'px';
    popup.classList.add('visible');
}

function hideNodePopup() {
    const popup = document.getElementById('nodePopup');
    popup.classList.remove('visible');
}

function toggleFullscreen() {
    const container = document.getElementById('networkContainer');
    const btn = document.getElementById('fullscreenBtn');
    
    if (!container.classList.contains('fullscreen')) {
        // Enter fullscreen
        container.classList.add('fullscreen');
        btn.innerHTML = '<i class="fas fa-compress"></i> Exit Full Screen';
        
        // Resize network to fit new container
        if (network) {
            network.fit({ animation: true });
        }
    } else {
        // Exit fullscreen
        container.classList.remove('fullscreen');
        btn.innerHTML = '<i class="fas fa-expand"></i> Full Screen';
        
        // Hide popup when exiting fullscreen
        hideNodePopup();
        
        // Resize network back to normal
        if (network) {
            network.fit({ animation: true });
        }
    }
    
    // Handle ESC key to exit fullscreen
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && container.classList.contains('fullscreen')) {
            toggleFullscreen();
        }
    });
}

function resetNetwork() {
    if (network) {
        // Reset physics and re-stabilize
        network.setOptions({
            physics: {
                enabled: true,
                stabilization: {
                    iterations: 100
                }
            }
        });
        
        // Fit to view after stabilization
        network.once('stabilizationIterationsDone', function() {
            network.fit({ animation: true });
        });
        
        // Hide table details panel and popup
        document.getElementById('tableDetails').style.display = 'none';
        hideNodePopup();
        
        // Stabilize the network
        network.stabilize();
    }
}

// Load data on page load
document.addEventListener('DOMContentLoaded', loadSchemaData);
</script>
{% endblock %}
